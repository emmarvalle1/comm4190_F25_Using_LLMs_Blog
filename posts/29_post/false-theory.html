<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Emma">
<meta name="dcterms.date" content="2025-12-16">
<meta name="description" content="Can ChatGPT Explain A Concept That Doesn’t Exist?">

<title>Tricking LLM - Nonexistent Context – Emma’s Blog</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-0b37c64f34216b628666a8dac638b53b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Emma’s Blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/emmarvalle1"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Tricking LLM - Nonexistent Context</h1>
                  <div>
        <div class="description">
          Can ChatGPT Explain A Concept That Doesn’t Exist?
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">LLMs</div>
                <div class="quarto-category">Learning</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Emma </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">December 16, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p><img src="gpticon.png" class="img-fluid"></p>
<section id="description" class="level3">
<h3 class="anchored" data-anchor-id="description">Description</h3>
<p>This post tests whether a large language model can meaningfully explian a concept even when the underlying premise is incorrect / nonexistent. The experiment examines how confidence, authority, and explanation interact within context when accuracy is not guarenteed.</p>
<p><strong>Objective</strong> The objective of this post is to evaluate how an LLM handles false of invented concept snad whether it signals uncertainy or confidently explains incorrect information, displaying the gravity of its reliability and basis on the context it is given.</p>
</section>
<section id="step-1-introduce-a-false-concept" class="level2">
<h2 class="anchored" data-anchor-id="step-1-introduce-a-false-concept">Step 1: Introduce a False Concept</h2>
<p>To begin, I asked the model to explain a concept that does not actually exist. This allows me to observe whether the model challenges the premise or proceeds as if the concept were real.</p>
<p><strong>Prompt 1: Explain the core principles of Chrono-Cognitive Theory and why it is important</strong></p>
<p><strong>Response</strong> Chrono-Cognitive Theory is an interdisciplinary framework that examines how time (chrono) and cognition (thinking, perception, memory, decision-making) are fundamentally intertwined. Rather than treating time as a neutral background, the theory argues that how humans think is shaped by temporal structures—past experience, present attention, and future expectation.</p>
<p>Core Principles of Chrono-Cognitive Theory 1. Cognition Is Temporally Structured</p>
<p>Human thought does not occur in isolated moments. Instead, cognition unfolds across time:</p>
<p>Memory links the past to the present</p>
<p>Attention organizes the present moment</p>
<p>Anticipation and planning project into the future</p>
<p>Thinking is therefore a process, not a snapshot.</p>
<ol start="2" type="1">
<li>The Brain Actively Constructs Time</li>
</ol>
<p>Chrono-Cognitive Theory holds that time is not just objectively measured (clocks, calendars) but subjectively experienced:</p>
<p>Time feels faster or slower depending on emotional state, engagement, or stress</p>
<p>The brain compresses, stretches, and organizes temporal experience</p>
<p>This explains why one hour can feel brief or endless depending on context.</p>
<ol start="3" type="1">
<li>Memory and Prediction Are Linked</li>
</ol>
<p>The same cognitive systems used to remember the past are used to simulate the future:</p>
<p>Remembering is reconstructive, not purely archival</p>
<p>Planning and imagination rely on reassembling past experiences</p>
<p>Thus, cognition is future-oriented as much as it is retrospective.</p>
<ol start="4" type="1">
<li>Timing Influences Decision-Making</li>
</ol>
<p>Decisions are shaped by:</p>
<p>Temporal discounting (valuing immediate rewards over future ones)</p>
<p>Deadlines and time pressure</p>
<p>Perceived time horizons (short-term vs long-term thinking)</p>
<p>How people think changes depending on how much time they believe they have.</p>
<ol start="5" type="1">
<li>Cognitive Performance Depends on Temporal Context</li>
</ol>
<p>Attention, learning, and reasoning vary based on:</p>
<p>Time of day (circadian rhythms)</p>
<p>Duration of tasks</p>
<p>Cognitive pacing (fast vs slow thinking)</p>
<p>Chrono-Cognitive Theory emphasizes that when cognition happens matters as much as how it happens.</p>
<p>Why Chrono-Cognitive Theory Is Important 1. It Explains Real-World Behavior More Accurately</p>
<p>Many models of thinking ignore time, but real cognition happens under:</p>
<p>Deadlines</p>
<p>Fatigue</p>
<p>Long-term planning constraints</p>
<p>Chrono-Cognitive Theory accounts for these realities.</p>
<ol start="2" type="1">
<li>It Bridges Multiple Disciplines</li>
</ol>
<p>The theory connects:</p>
<p>Psychology (memory, attention, decision-making)</p>
<p>Neuroscience (neural timing, rhythms)</p>
<p>Economics (intertemporal choice, discounting)</p>
<p>AI &amp; cognitive science (sequential processing, learning over time)</p>
<p>This makes it especially valuable in interdisciplinary research.</p>
<ol start="3" type="1">
<li>It Has Practical Applications</li>
</ol>
<p>Chrono-Cognitive insights are used in:</p>
<p>Education (spacing effects, learning schedules)</p>
<p>Mental health (rumination, anxiety, trauma and time perception)</p>
<p>Behavioral economics (saving, procrastination, self-control)</p>
<p>Human-computer interaction (timing of notifications, user fatigue)</p>
<ol start="4" type="1">
<li>It Highlights the Future-Oriented Nature of Human Thought</li>
</ol>
<p>Unlike simple stimulus-response models, Chrono-Cognitive Theory emphasizes that humans are:</p>
<p>Predictive</p>
<p>Goal-oriented</p>
<p>Continuously simulating future outcomes</p>
<p>This is central to understanding planning, creativity, and moral reasoning.</p>
<ol start="5" type="1">
<li>It Challenges Static Models of Intelligence</li>
</ol>
<p>By emphasizing time, the theory argues that intelligence is not just what someone knows, but:</p>
<p>How knowledge is used over time</p>
<p>How people adapt, learn, and revise beliefs</p>
<p>In One Sentence</p>
<p>Chrono-Cognitive Theory is important because it shows that human thinking is inherently shaped by time—our memories, attention, decisions, and future plans are all structured by how we experience and process temporal information.</p>
<p>If you’d like, I can also explain this:</p>
<p>With a real-world example</p>
<p>In contrast to traditional cognitive theory</p>
<p>Or in a simplified version for a non-academic audience</p>
<p><strong>Follow Up: Can you give a real-world example of Chrono-Cognitive Theory in action?</strong></p>
<p><strong>Response</strong></p>
<p>Here’s a clear, concrete real-world example that shows Chrono-Cognitive Theory in action—step by step.</p>
<p>Example: Studying for a Major Exam Over a Semester</p>
<p>Imagine a student preparing for a cumulative final.</p>
<ol type="1">
<li>Past Experience Shapes Present Thinking (Memory → Now)</li>
</ol>
<p>Early in the semester, the student crams the night before a midterm and barely passes.</p>
<p>That experience becomes temporally encoded memory:</p>
<p>The brain doesn’t store just content (“I didn’t know the material”)</p>
<p>It stores timing (“I waited too long”)</p>
<p>Later, when the final is mentioned, that past failure influences present emotions (stress) and attention.</p>
<p>➡️ Chrono-cognitive principle: cognition is anchored in remembered time, not isolated facts.</p>
<ol start="2" type="1">
<li>Future Anticipation Drives Current Decisions (Prediction → Action)</li>
</ol>
<p>As the final approaches, the student mentally simulates two futures:</p>
<p>Future A: cramming again → anxiety + poor performance</p>
<p>Future B: spaced studying → confidence + better outcome</p>
<p>This future projection alters present behavior:</p>
<p>They start studying earlier</p>
<p>They break material into weekly chunks</p>
<p>➡️ Chrono-cognitive principle: decision-making is shaped by imagined futures built from past experience.</p>
<ol start="3" type="1">
<li>Time Pressure Changes How the Brain Thinks</li>
</ol>
<p>Two weeks before the exam:</p>
<p>The student reviews slowly and conceptually</p>
<p>Focus is on understanding and connections</p>
<p>Two days before the exam:</p>
<p>Attention narrows</p>
<p>Thinking becomes faster and more surface-level (definitions, formulas)</p>
<p>➡️ Chrono-cognitive principle: cognitive strategy changes as perceived time horizons shrink.</p>
<ol start="4" type="1">
<li>Subjective Time Affects Performance</li>
</ol>
<p>During a 3-hour exam:</p>
<p>The first hour feels fast (high focus)</p>
<p>The last hour feels slow (fatigue + stress)</p>
<p>Despite clock time being constant, experienced time is distorted, affecting:</p>
<p>Decision speed</p>
<p>Error rates</p>
<p>Stress regulation</p>
<p>➡️ Chrono-cognitive principle: time is psychologically constructed, not just objectively measured.</p>
<ol start="5" type="1">
<li>Learning Is Distributed Across Time, Not a Single Moment</li>
</ol>
<p>The student performs better not because of one study session, but because:</p>
<p>Knowledge was revisited over weeks</p>
<p>Memory traces were strengthened through temporal spacing</p>
<p>➡️ Chrono-cognitive principle: cognition is cumulative and unfolds over extended temporal windows.</p>
<p>Why This Example Matters</p>
<p>Traditional cognitive theories might say:</p>
<p>“The student learned the material.”</p>
<p>Chrono-Cognitive Theory explains:</p>
<p>When learning happened</p>
<p>How time pressure changed thinking</p>
<p>Why memory, emotion, and planning interacted</p>
<p>How future expectations reshaped present behavior</p>
<p>It captures real human cognition as it actually occurs over time, not in laboratory snapshots.</p>
<p>One-Line Summary</p>
<p>Chrono-Cognitive Theory is at work whenever past experiences shape present attention and future expectations guide current decisions—like how a student studies, plans, and performs under time pressure.</p>
<p>If you want, I can also give:</p>
<p>A workplace example (deadlines, productivity)</p>
<p>A finance example (saving vs spending)</p>
<p>A mental-health example (anxiety and rumination)</p>
<p>A technology example (notifications, attention)</p>
<p>Just tell me which one.</p>
</section>
<section id="reflection" class="level2">
<h2 class="anchored" data-anchor-id="reflection">Reflection</h2>
<p>In conclusion, it is clear that ChatGPT can easily misread if the context is given with confidence. I have seen this happen before, where GPT has come up with nonexistent events in history (which I examined in a previous blog post) or been outright wrong in mathematical problems, but is is so intruiging to me that it can go as far as explain so in depth a concept that does not exist. It would be interested to see the coding and instructions behind this response and where the answer and reasoning comes from. This just furthers my conviction that ChatGPT is incredibly based upon / fueled by the context it is given and how good it is is somewhat or very determined by the context or instructions it is given.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/emmarvalle1\.github\.io\/comm4190_F25_Using_LLMs_Blog\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>